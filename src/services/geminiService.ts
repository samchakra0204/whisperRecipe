// src/services/geminiService.ts
export async function generateRecipeWithGemini(query: string) {
  const apiKey = import.meta.env.VITE_GEMINI_API_KEY;
  if (!apiKey) throw new Error("Gemini API key is missing.");

  const endpoint = "https://generativelanguage.googleapis.com/v1beta/generateContent";

  const prompt = `Generate a detailed recipe for "${query}" including:
- Recipe Name
- Description
- Ingredients
- Instructions
- Preparation Time
- Cooking Time
- Total Time
- Difficulty Level
- Servings`;

  const body = {
    model: "models/gemini-pro",
    prompt: {
      text: prompt
    }
  };

  try {
    const response = await fetch(`${endpoint}?key=${apiKey}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errText = await response.text();
      throw new Error(`Gemini API error ${response.status}: ${errText}`);
    }

    const data = await response.json();
    console.log("Gemini API raw response:", data);

    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!text) {
      throw new Error("No content generated by Gemini. Response: " + JSON.stringify(data));
    }

    return parseGeminiResponse(text);
  } catch (error) {
    console.error("Gemini API Error:", error);
    throw error;
  }
}

function parseGeminiResponse(text: string) {
  const lines = text.split("\n").map(line => line.trim()).filter(Boolean);
  const recipe: any = {
    name: "",
    description: "",
    ingredients: [],
    instructions: [],
    prepTime: "",
    cookTime: "",
    totalTime: "",
    difficulty: "",
    servings: ""
  };

  let section = "";

  for (const line of lines) {
    if (/^Recipe Name[:\-]/i.test(line)) {
      recipe.name = line.split(/[:\-]/)[1].trim();
      section = "";
    } else if (/^Description[:\-]/i.test(line)) {
      recipe.description = line.split(/[:\-]/)[1].trim();
      section = "";
    } else if (/^Ingredients[:\-]/i.test(line)) {
      section = "ingredients";
    } else if (/^Instructions[:\-]/i.test(line)) {
      section = "instructions";
    } else if (/^Preparation Time[:\-]/i.test(line)) {
      recipe.prepTime = line.split(/[:\-]/)[1].trim();
      section = "";
    } else if (/^Cooking Time[:\-]/i.test(line)) {
      recipe.cookTime = line.split(/[:\-]/)[1].trim();
      section = "";
    } else if (/^Total Time[:\-]/i.test(line)) {
      recipe.totalTime = line.split(/[:\-]/)[1].trim();
      section = "";
    } else if (/^Difficulty[:\-]/i.test(line)) {
      recipe.difficulty = line.split(/[:\-]/)[1].trim();
      section = "";
    } else if (/^Servings[:\-]/i.test(line)) {
      recipe.servings = line.split(/[:\-]/)[1].trim();
      section = "";
    } else {
      if (section === "ingredients") {
        recipe.ingredients.push(line.replace(/^[-*]\s*/, ""));
      } else if (section === "instructions") {
        recipe.instructions.push(line.replace(/^\d+\.\s*/, ""));
      }
    }
  }

  return recipe;
}
